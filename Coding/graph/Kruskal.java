package graph;

import java.util.ArrayList;
import java.util.Scanner;

/**
 * 
 * 最小生成树kruskal算法：首先将每个顶点作为一棵森林，升序比较该顶点的邻接边，
 * 每次取最小权值的邻接边，将该邻接边连接的顶点与原先顶点构成一棵树，接着寻找
 * 下一个顶点，继续按照邻接边权值升序进行比较，取权值最小的构成树...
 *
 *该类用一个Edge类构成一个邻接边的信息，包括邻接边的起始顶点与结束顶点，权值。
 * 用类Edge创建对象，录入对象信息，按照对象的权值进行比较，符合条件的对象加入
 * 到链表中，最终按照链表顺序输出最小生成树。
 */

public class Kruskal {
	/**
	 * 
	 * Max:定义顶点数组的最大值
  * edge:链表edge，存储构造的Edge对象
  * target:链表trget,存储最终得到结果的Edge对象
  * parent:存储顶点信息的数组
  * n:顶点数
  */
	
	int Max=100;
	ArrayList<Edge> edge=new ArrayList<Edge>();
	ArrayList<Edge> target=new ArrayList<Edge>();
	int[] parent=new int[Max];
	Float TheMax=Float.MAX_VALUE;
	int n;
	
	public void init(){
		Scanner scan=new Scanner(System.in);
		int p,q;
		double w;
		System.out.println("请输入节点的个数:");
		n=scan.nextInt();
		System.out.println("按照‘A,B,C’的格式输入边与边的信息，ABC分别代表边的起始顶点，结束顶点，权值(输入-1-1-1结束输入)");
		while(true){
			p=scan.nextInt();
			q=scan.nextInt();
			w=scan.nextDouble();
			if(p<0||q<0||w<0){
				break;
			}
			Edge e=new Edge();
			e.start=p;
			e.weight=w;
			edge.add(e);
			for(int i=1;i<=n;++i){
				parent[i]=i;
			}
		}
	}
		
		public void union(int j,int k){
			for(int i=1;i<n;i++){
				if(parent[i]==j){
					parent[i]=k;
				}
			}
		}
	
	
	public void kruskal(){
		int i=0;
		while(i<n-1&&edge.size()>0){
			double min=Double.MAX_VALUE;
			Edge temp=null;
			for(int j=0;j<edge.size();++j){
				Edge tt=edge.get(j);
				if(tt.weight<min){
					min=tt.weight;
					temp=tt;
				}
			}
		
	
	
	int jj=parent[temp.start];
	int kk=parent[temp.end];
	
	if(jj!=kk){
		++i;
		target.add(temp);
		union(jj,kk);
	}
	edge.remove(temp);
	}
		System.out.println("最小生成树的路径是:");
		for(int k=0;k<target.size();++k){
			Edge e=target.get(k);
			System.out.println(e.start+"-->"+e.end);
		}
	}
	

	public static void main(String[] args) {
		 Kruskal kr=new  Kruskal();
		   kr.init();
		   kr.kruskal();

	}

}
